#pragma once
#include <iostream>
#include <float.h>
#include "arena_dynamic_channel/graph/delaunator.h"


namespace delaunator {


/*
 * details: https://mapbox.github.io/delaunator/#point-to-edges
 *
 * rank: the position of a vertex in 'coord' vector
 *
 * index: the index of 'triangles' is the id of each triangle vertex, which is generated by hashing
 *        the value stored in 'triangles' is the unique rank of the vertex in the graph
 *        Please make a clear understanding about these two variables
 *
 *        the index and value of 'halfedges' are ids of a triangle vertex
 *        representing the end and start of a half edge, respectively
 *        the value and index represent the opposite half edge, which are
 *        generated by the opposite vertex.
 *
 *
 * important: if you want to retrieve a triangle, use nextHalfedge in 'triangles'
 *            if you want to retrieve a couple of half edges, use 'halfedges'
 **/
typedef std::size_t rank;  // the unique rank of a vertex
typedef std::size_t index;  // the unique index of an edge


/*
 * represent a triangle with its vertex indices
 * the vertices are located anti-clockwise
**/
struct Face{
    index v0;
    index v1;
    index v2;
};


/*
 * utility functions
**/
inline index nextHalfedge(index e) { return (e % 3 == 2) ? e - 2 : e + 1; }
inline index prevHalfedge(index e) { return (e % 3 == 0) ? e + 2 : e - 1; }


/*
 * graph: the pointer of a Delaunator instance
 * face_point: the current face visited by robot
 *             each face contains three vertex indices [t, t+1, t+2]
 *             we use any of the indices as face representation
 *             the other two indices can be visited by nextHalfedge or prevHalfedge
 * neighbors: the output vector of neighbors,
 *            each of which is represented by one of the vertex indices of the adjacent triangle
 * outgoings: the corresponding vertex indices of the curren triangle
 *
**/
void neighborTriangles(const Delaunator* graph,
                       const index triangle_id,
                       std::vector<index>& neighbors,
                       std::vector<index>& outgoings);

void neighborVertices(const Delaunator* graph,
                      const index cur_eid,
                      std::vector<index>& neighbors);



/*
 * graph: the pointer of a Delaunator instance
 * face_cent: the centroid of a trangle
**/
void calculateFaceCenters(const Delaunator* graph, std::vector<double>& center);

/*
 * cx, cy: the coordinite of test point
 * a, b, c: the vertices of a triangle, -> a --> b --> c -
 * return True: inside the triangle
 * returen False: not insider the triangle
 *
**/
inline bool isInsideTriangle(double px, double py,
                             double ax, double ay,
                             double bx, double by,
                             double cx, double cy)
{
    double abp = (ax - px) * (by - py) - (ay - py) * (bx - px);
    double bcp = (bx - px) * (cy - py) - (by - py) * (cx - px);
    double cap = (cx - px) * (ay - py) - (cy - py) * (ax - px);

    if ((abp <= 0 && bcp <= 0 && cap <= 0) || (abp >= 0 && bcp >= 0 && cap >= 0)){
        return true;
    }else {
        return false;
    }
}

inline bool isOnLeft(double px, double py, double ax, double ay, double bx, double by){
    double abp = (ax - px) * (by - py) - (ay - py) * (bx - px);
    if(abp <= 0){
        return true;
    }else {
        return false;
    }
}


/*
 ** Important **
 * 1. The start and goal of planning should participate in triangulation
 *    Once the robot runs outside the convex hull, the start point that
 *    participates in triangulation should be replaced with the current
 *    robot position.
 * 2. There is at least one triangular
 *
 *
 * graph: the pointer of a Delaunator instance
 * cx, cy: the coordinite of test point
 * output: the index of triangular vertex
 * distance: the squared distance to the nearest obstacle
 *
 * return fasle if (px, py) lies in a region controlled by pedestrians
 *
 * return true if successfully locate the face. Invalid means out side the convex hull
 * the output the traingle vertex index of the nearest vertex, i.e., the eid
 *
 *
**/
bool locateCurrentFace(const Delaunator* graph,
                       const double px, const double py,
                       index& output, double& distance,
                       double SAFE_DIST=0.5, size_t PED_START=6);
                       
size_t locateCurrentFace(const Delaunator* graph, const double px, const double py);
} // end namespace
